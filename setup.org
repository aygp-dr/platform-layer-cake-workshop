#+TITLE: Layered Recovery Architecture: Breaking Circular Dependencies
#+AUTHOR: Workshop Materials
#+DATE: 2025-11-25
#+PROPERTY: header-args :mkdirp t
#+STARTUP: overview

* Overview

This document explores layered architecture patterns for platform recovery, comparing approaches from Atlassian's CPR (Continuous PaaS Recovery) program and Netflix's chaos engineering practices.

** Key Concepts
- Circular dependencies prevent disaster recovery
- Layer cake architecture enables bottom-up recovery
- Hard vs soft dependencies
- Dependency tangles and their risks

* References

** Primary Sources

*** Atlassian CPR Program
- [[https://www.atlassian.com/blog/atlassian-engineering/removing-dependency-tangles-in-the-atlassian-platform-for-increased-reliability-and-recoverability][Removing dependency tangles in the Atlassian Platform]]
- [[https://www.theregister.com/2025/11/25/atlassian_dependency_migration/][The Register: Atlassian's DR simulation]]

*** Netflix Chaos Engineering
- Netflix OSS: Hystrix, Eureka, Ribbon, Zuul
- Chaos Monkey and Simian Army
- [[https://netflixtechblog.com/][Netflix Technology Blog]]

** Key Statistics

From Atlassian's platform:
- 2000+ services
- 5000+ daily deployments
- 40,000+ DynamoDB tables
- 80,000+ RDS tables
- 3 million Lambda functions
- 4-year remediation program
- Hundreds of circular dependencies eliminated

* Core Problem: Circular Dependencies

** Definition

A circular dependency occurs when:
- Service A depends on Service B
- Service B depends on Service A
- Result: If both fail, neither can recover

** Real Example: Atlassian 2021

#+begin_src mermaid :file images/circular-dependency.png :tangle diagrams/circular-dependency.mmd
graph TB
    A[Artifactory<br/>Docker Registry] -->|deployed by| B[Micros<br/>Orchestration]
    B -->|needs containers from| A
    
    style A fill:#ff6b6b
    style B fill:#ff6b6b
    
    C[Recovery Impossible<br/>Both services down] -.-> A
    C -.-> B
#+end_src

** Causes of Dependency Tangles

1. *Feature Development* - Services communicate, creating dependency mesh
2. *Evolution* - New frameworks change underlying dependencies
3. *Centralization* - Capabilities consolidate into shared services
4. *Standardization* - Multiple solutions narrow to single provider
5. *Service Proliferation* - Unchecked growth increases risk
6. *Monolith Decomposition* - Poor boundaries create tangles

* Solution: Layer Cake Architecture

** Core Principles

#+begin_quote
A component in layer N can only have hard dependencies on lower layers
- N → N-1 = Good ✓
- N → N = Bad ✗
- N → N+1 = Bad ✗
#+end_quote

** Layer Structure

#+begin_src mermaid :file images/layer-cake.png :tangle diagrams/layer-cake.mmd
graph TB
    subgraph "Layer 7: Products"
        L7A[Jira]
        L7B[Confluence]
        L7C[Bitbucket]
    end
    
    subgraph "Layer 6: Application Services"
        L6A[Feature Flags]
        L6B[Logging]
        L6C[Metrics]
    end
    
    subgraph "Layer 5: Platform Services"
        L5A[Micros]
        L5B[Kubernetes]
    end
    
    subgraph "Layer 4: Core Infrastructure"
        L4A[Artifactory]
        L4B[APD]
    end
    
    subgraph "Layer 3: Networking"
        L3A[VPC]
        L3B[DNS]
        L3C[Load Balancers]
    end
    
    subgraph "Layer 2: Authentication"
        L2A[IAM]
        L2B[Auth Services]
    end
    
    subgraph "Layer 1: Cloud Provider"
        L1A[AWS EC2]
        L1B[AWS S3]
        L1C[AWS RDS]
    end
    
    L7A & L7B & L7C --> L6A & L6B & L6C
    L6A & L6B & L6C --> L5A & L5B
    L5A & L5B --> L4A & L4B
    L4A & L4B --> L3A & L3B & L3C
    L3A & L3B & L3C --> L2A & L2B
    L2A & L2B --> L1A & L1B & L1C
    
    style L7A fill:#e3f2fd
    style L7B fill:#e3f2fd
    style L7C fill:#e3f2fd
    style L4A fill:#fff3e0
    style L4B fill:#fff3e0
    style L1A fill:#f1f8e9
    style L1B fill:#f1f8e9
    style L1C fill:#f1f8e9
#+end_src

** Dependency Types

*** Hard Dependencies
Essential for operation - service cannot function without them
- AWS infrastructure
- Networking
- Authentication
- Critical data stores

*** Soft Dependencies
Service operates with limited capabilities
- Logging
- Metrics
- Alerting
- Feature flags

* Atlassian's CPR Implementation

** Phase 1: Analysis (2021-2022)

*** Discovery Process
1. Survey hundreds of service owners
2. Map deploy-time dependencies
3. Map runtime dependencies
4. Categorize as hard/soft
5. Build dependency database

*** Tabletop Exercise (March 2023)
- 40 representatives from 26 PaaS teams
- 8-hour session simulating 6.5 days recovery
- Revealed dozens of unrecoverable services
- Identified critical dependency risks

** Phase 2: Core Infrastructure (2022-2023)

*** Source Control Pillar (SCP)

#+begin_src mermaid :file images/scp-architecture.png :tangle diagrams/scp-architecture.mmd
graph LR
    A[Bitbucket<br/>Layer 36] -->|webhook| B[SCP<br/>Layer 2]
    B -->|mirror| C[AWS CodeCommit<br/>Layer 1]
    C -->|pull code| D[Build Pipeline]
    D -->|deploy| E[Platform Services]
    
    style B fill:#4caf50
    style C fill:#8bc34a
#+end_src

*Key Achievement:* Network team could access Infrastructure as Code during recovery

*** Artifactory Migration

#+begin_src python :tangle src/dependency_analyzer.py
"""
Analyze circular dependencies in service architecture
"""

from typing import Set, Dict, List, Tuple
from dataclasses import dataclass
from enum import Enum

class DependencyType(Enum):
    HARD = "hard"
    SOFT = "soft"

@dataclass
class Service:
    name: str
    layer: int
    dependencies: Dict[str, DependencyType]
    
def detect_circular_dependencies(services: Dict[str, Service]) -> List[Tuple[str, str]]:
    """
    Detect circular dependencies in service graph
    
    Returns list of (service_a, service_b) tuples representing cycles
    """
    cycles = []
    
    def has_path(start: str, end: str, visited: Set[str] = None) -> bool:
        if visited is None:
            visited = set()
        
        if start == end:
            return True
        
        if start in visited:
            return False
            
        visited.add(start)
        
        service = services.get(start)
        if not service:
            return False
            
        for dep_name, dep_type in service.dependencies.items():
            if dep_type == DependencyType.HARD:
                if has_path(dep_name, end, visited.copy()):
                    return True
        
        return False
    
    # Check each pair of services
    for svc_a in services:
        for svc_b in services:
            if svc_a != svc_b:
                # Check if A->B and B->A both exist
                if (has_path(svc_a, svc_b) and 
                    has_path(svc_b, svc_a)):
                    # Avoid duplicate entries
                    pair = tuple(sorted([svc_a, svc_b]))
                    if pair not in cycles:
                        cycles.append(pair)
    
    return cycles

def validate_layering(services: Dict[str, Service]) -> List[str]:
    """
    Validate that services only depend on lower layers
    
    Returns list of violations
    """
    violations = []
    
    for svc_name, service in services.items():
        for dep_name, dep_type in service.dependencies.items():
            if dep_type == DependencyType.HARD:
                dep_service = services.get(dep_name)
                if dep_service:
                    if dep_service.layer >= service.layer:
                        violation = (
                            f"{svc_name} (L{service.layer}) depends on "
                            f"{dep_name} (L{dep_service.layer})"
                        )
                        violations.append(violation)
    
    return violations

# Example usage
if __name__ == "__main__":
    # Atlassian 2021 problem scenario
    services = {
        "artifactory": Service(
            name="artifactory",
            layer=5,
            dependencies={"micros": DependencyType.HARD}
        ),
        "micros": Service(
            name="micros",
            layer=5,
            dependencies={"artifactory": DependencyType.HARD}
        )
    }
    
    cycles = detect_circular_dependencies(services)
    print(f"Circular dependencies found: {cycles}")
    
    violations = validate_layering(services)
    print(f"Layer violations: {violations}")
#+end_src

Migration strategy:
- Move from Micros (Layer 5) to Kubernetes (Layer 5)
- Break cycle: Kubernetes can recover Artifactory
- Artifactory can then recover Micros

Scale handled:
- 2.5M requests/minute (~40K/second)
- 5 Gbps network traffic
- 250-400 TB downloaded daily
- 990 TB stored (348M objects)

*** Atlassian Platform Deployer (APD)

New low-dependency provisioning system to replace Micros for critical services.

Design principles:
- API-based web service
- No external database (AWS as source of truth)
- Uses CloudFormation as orchestration engine
- Minimal feature set (vs Micros)
- Restricted customer base (platform services only)

#+begin_src mermaid :file images/apd-stacks.png :tangle diagrams/apd-stacks.mmd
graph TB
    subgraph "Deployment v1.1"
        D2[Deployment Stack v1.1]
        DR2[Deployment Resources v1.1]
    end
    
    subgraph "Deployment v1.0 (cleanup)"
        D1[Deployment Stack v1.0]
        DR1[Deployment Resources v1.0]
    end
    
    subgraph "Persistent"
        E[Environment Stack]
        R[Route Stack]
        ER[Eternal Resources Stack]
    end
    
    R -->|traffic switch| D2
    R -.->|old traffic| D1
    E --> D2
    E -.-> D1
    D2 --> DR2
    D2 --> ER
    
    style D2 fill:#4caf50
    style D1 fill:#ff9800
    style R fill:#2196f3
#+end_src

** Phase 3: Support Systems (2023-2024)

*** Config Pillar
- Replaced higher-layer feature flag system
- AWS-native using Open Policy Agent (OPA)
- 700+ flags managed
- Available during recovery

*** Logging Pillar
- Kinesis stream as backup to observability pipeline
- Dormant during normal operations
- Activates during disasters
- Provides CloudWatch access for debugging

*** PaaS Dependency Visualization System (PDVS)
- Web frontend for all dependency data
- Tangle heat maps
- Recommendations for breaking cycles
- Model versioning and simulation
- VPC flow log integration

** Phase 4: Migration (2024-2025)

*** Traffic Migration Proxy (TMP)
- Envoy-based HTTP proxy sidecar
- Routes traffic between AWS accounts
- Synchronizes persistent stores (Dynamo, S3, RDS)
- Multi-region, multi-environment support

*** Micros Migration to APD
- July 2025 completion
- Phased rollout over several months
- Last critical service migrated

* Netflix's Approach

** Chaos Engineering Principles

1. *Build a hypothesis around steady state*
2. *Vary real-world events*
3. *Run experiments in production*
4. *Automate experiments*
5. *Minimize blast radius*

** Key Tools

*** Hystrix (Circuit Breaker)
- Fallback mechanisms
- Real-time monitoring
- Fault tolerance
- Dependency isolation

*** Eureka (Service Discovery)
- Dynamic service registration
- Health checks
- Load balancing integration

*** Chaos Monkey
- Random instance termination
- Validates resilience
- Forces best practices

** Layered Architecture Comparison

Both Netflix and Atlassian use similar concepts:
- Services organized by dependency levels
- Lower layers more stable/reliable
- Higher layers can fail without cascading
- Recovery proceeds bottom-up

* Workshop Exercises

** Exercise 1: Dependency Mapping

*** Goal
Map dependencies for a sample microservices architecture

*** Setup
#+begin_src python :tangle exercises/ex1_dependency_map.py
"""
Exercise 1: Create a dependency map for your services
"""

from src.dependency_analyzer import Service, DependencyType

# TODO: Define your services
services = {
    # Example:
    # "api-gateway": Service(
    #     name="api-gateway",
    #     layer=3,
    #     dependencies={
    #         "auth-service": DependencyType.HARD,
    #         "logging": DependencyType.SOFT
    #     }
    # ),
}

# Task 1: Add at least 5 services with dependencies
# Task 2: Run circular dependency detection
# Task 3: Fix any cycles found
#+end_src

** Exercise 2: Layer Assignment

*** Goal
Assign services to layers following the layer cake model

*** Constraints
- AWS/Cloud provider = Layer 1
- Products/Applications = Highest layer
- No hard dependencies on same/higher layers

#+begin_src python :tangle exercises/ex2_layer_assignment.py
"""
Exercise 2: Assign services to appropriate layers
"""

services = {
    "database": {"current_layer": None, "dependencies": ["aws-rds"]},
    "auth": {"current_layer": None, "dependencies": ["database"]},
    "api": {"current_layer": None, "dependencies": ["auth", "database"]},
    "frontend": {"current_layer": None, "dependencies": ["api"]},
    "aws-rds": {"current_layer": 1, "dependencies": []},
}

def assign_layers(services):
    """
    Assign each service to a layer based on dependencies
    
    Rules:
    1. Services with no dependencies → Layer 2 (Layer 1 is cloud)
    2. Services depend only on lower layers
    3. Minimize layer count while respecting dependencies
    """
    # TODO: Implement layer assignment algorithm
    pass

# Task: Implement assign_layers() function
# Verify no layer violations exist
#+end_src

** Exercise 3: Simulate Tabletop Exercise

*** Scenario
Complete platform outage - recover services in order

*** Recovery Steps
#+begin_src python :tangle exercises/ex3_recovery_simulation.py
"""
Exercise 3: Simulate disaster recovery
"""

from typing import Set
import time

class RecoverySimulation:
    def __init__(self, services):
        self.services = services
        self.recovered = set()
        self.failed_attempts = []
        
    def can_recover(self, service_name: str) -> bool:
        """
        Check if service can be recovered
        All hard dependencies must be recovered first
        """
        service = self.services[service_name]
        
        for dep_name, dep_type in service.dependencies.items():
            if dep_type == DependencyType.HARD:
                if dep_name not in self.recovered:
                    return False
        
        return True
    
    def recover_service(self, service_name: str) -> bool:
        """
        Attempt to recover a service
        """
        if self.can
