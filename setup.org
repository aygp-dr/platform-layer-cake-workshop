#+TITLE: Layered Recovery Architecture: Breaking Circular Dependencies
#+AUTHOR: Workshop Materials
#+DATE: 2025-11-25
#+PROPERTY: header-args :mkdirp t
#+STARTUP: overview

* Overview

This document explores layered architecture patterns for platform recovery, comparing approaches from Atlassian's CPR (Continuous PaaS Recovery) program and Netflix's chaos engineering practices.

** Key Concepts
- Circular dependencies prevent disaster recovery
- Layer cake architecture enables bottom-up recovery
- Hard vs soft dependencies
- Dependency tangles and their risks

* References

** Primary Sources

*** Atlassian CPR Program
- [[https://www.atlassian.com/blog/atlassian-engineering/removing-dependency-tangles-in-the-atlassian-platform-for-increased-reliability-and-recoverability][Removing dependency tangles in the Atlassian Platform]]
- [[https://www.theregister.com/2025/11/25/atlassian_dependency_migration/][The Register: Atlassian's DR simulation]]

*** Netflix Chaos Engineering
- Netflix OSS: Hystrix, Eureka, Ribbon, Zuul
- Chaos Monkey and Simian Army
- [[https://netflixtechblog.com/][Netflix Technology Blog]]

** Key Statistics

From Atlassian's platform:
- 2000+ services
- 5000+ daily deployments
- 40,000+ DynamoDB tables
- 80,000+ RDS tables
- 3 million Lambda functions
- 4-year remediation program
- Hundreds of circular dependencies eliminated

* Core Problem: Circular Dependencies

** Definition

A circular dependency occurs when:
- Service A depends on Service B
- Service B depends on Service A
- Result: If both fail, neither can recover

** Real Example: Atlassian 2021

#+begin_src mermaid :file images/circular-dependency.png :tangle diagrams/circular-dependency.mmd
graph TB
    A[Artifactory<br/>Docker Registry] -->|deployed by| B[Micros<br/>Orchestration]
    B -->|needs containers from| A
    
    style A fill:#ff6b6b
    style B fill:#ff6b6b
    
    C[Recovery Impossible<br/>Both services down] -.-> A
    C -.-> B
#+end_src

** Causes of Dependency Tangles

1. *Feature Development* - Services communicate, creating dependency mesh
2. *Evolution* - New frameworks change underlying dependencies
3. *Centralization* - Capabilities consolidate into shared services
4. *Standardization* - Multiple solutions narrow to single provider
5. *Service Proliferation* - Unchecked growth increases risk
6. *Monolith Decomposition* - Poor boundaries create tangles

* Solution: Layer Cake Architecture

** Core Principles

#+begin_quote
A component in layer N can only have hard dependencies on lower layers
- N → N-1 = Good ✓
- N → N = Bad ✗
- N → N+1 = Bad ✗
#+end_quote

** Layer Structure

#+begin_src mermaid :file images/layer-cake.png :tangle diagrams/layer-cake.mmd
graph TB
    subgraph "Layer 7: Products"
        L7A[Jira]
        L7B[Confluence]
        L7C[Bitbucket]
    end
    
    subgraph "Layer 6: Application Services"
        L6A[Feature Flags]
        L6B[Logging]
        L6C[Metrics]
    end
    
    subgraph "Layer 5: Platform Services"
        L5A[Micros]
        L5B[Kubernetes]
    end
    
    subgraph "Layer 4: Core Infrastructure"
        L4A[Artifactory]
        L4B[APD]
    end
    
    subgraph "Layer 3: Networking"
        L3A[VPC]
        L3B[DNS]
        L3C[Load Balancers]
    end
    
    subgraph "Layer 2: Authentication"
        L2A[IAM]
        L2B[Auth Services]
    end
    
    subgraph "Layer 1: Cloud Provider"
        L1A[AWS EC2]
        L1B[AWS S3]
        L1C[AWS RDS]
    end
    
    L7A & L7B & L7C --> L6A & L6B & L6C
    L6A & L6B & L6C --> L5A & L5B
    L5A & L5B --> L4A & L4B
    L4A & L4B --> L3A & L3B & L3C
    L3A & L3B & L3C --> L2A & L2B
    L2A & L2B --> L1A & L1B & L1C
    
    style L7A fill:#e3f2fd
    style L7B fill:#e3f2fd
    style L7C fill:#e3f2fd
    style L4A fill:#fff3e0
    style L4B fill:#fff3e0
    style L1A fill:#f1f8e9
    style L1B fill:#f1f8e9
    style L1C fill:#f1f8e9
#+end_src

** Dependency Types

*** Hard Dependencies
Essential for operation - service cannot function without them
- AWS infrastructure
- Networking
- Authentication
- Critical data stores

*** Soft Dependencies
Service operates with limited capabilities
- Logging
- Metrics
- Alerting
- Feature flags

* Atlassian's CPR Implementation

** Phase 1: Analysis (2021-2022)

*** Discovery Process
1. Survey hundreds of service owners
2. Map deploy-time dependencies
3. Map runtime dependencies
4. Categorize as hard/soft
5. Build dependency database

*** Tabletop Exercise (March 2023)
- 40 representatives from 26 PaaS teams
- 8-hour session simulating 6.5 days recovery
- Revealed dozens of unrecoverable services
- Identified critical dependency risks

** Phase 2: Core Infrastructure (2022-2023)

*** Source Control Pillar (SCP)

#+begin_src mermaid :file images/scp-architecture.png :tangle diagrams/scp-architecture.mmd
graph LR
    A[Bitbucket<br/>Layer 36] -->|webhook| B[SCP<br/>Layer 2]
    B -->|mirror| C[AWS CodeCommit<br/>Layer 1]
    C -->|pull code| D[Build Pipeline]
    D -->|deploy| E[Platform Services]
    
    style B fill:#4caf50
    style C fill:#8bc34a
#+end_src

*Key Achievement:* Network team could access Infrastructure as Code during recovery

*** Artifactory Migration

#+begin_src python :tangle src/dependency_analyzer.py
"""
Analyze circular dependencies in service architecture
"""

from typing import Set, Dict, List, Tuple
from dataclasses import dataclass
from enum import Enum

class DependencyType(Enum):
    HARD = "hard"
    SOFT = "soft"

@dataclass
class Service:
    name: str
    layer: int
    dependencies: Dict[str, DependencyType]
    
def detect_circular_dependencies(services: Dict[str, Service]) -> List[Tuple[str, str]]:
    """
    Detect circular dependencies in service graph
    
    Returns list of (service_a, service_b) tuples representing cycles
    """
    cycles = []
    
    def has_path(start: str, end: str, visited: Set[str] = None) -> bool:
        if visited is None:
            visited = set()
        
        if start == end:
            return True
        
        if start in visited:
            return False
            
        visited.add(start)
        
        service = services.get(start)
        if not service:
            return False
            
        for dep_name, dep_type in service.dependencies.items():
            if dep_type == DependencyType.HARD:
                if has_path(dep_name, end, visited.copy()):
                    return True
        
        return False
    
    # Check each pair of services
    for svc_a in services:
        for svc_b in services:
            if svc_a != svc_b:
                # Check if A->B and B->A both exist
                if (has_path(svc_a, svc_b) and 
                    has_path(svc_b, svc_a)):
                    # Avoid duplicate entries
                    pair = tuple(sorted([svc_a, svc_b]))
                    if pair not in cycles:
                        cycles.append(pair)
    
    return cycles

def validate_layering(services: Dict[str, Service]) -> List[str]:
    """
    Validate that services only depend on lower layers
    
    Returns list of violations
    """
    violations = []
    
    for svc_name, service in services.items():
        for dep_name, dep_type in service.dependencies.items():
            if dep_type == DependencyType.HARD:
                dep_service = services.get(dep_name)
                if dep_service:
                    if dep_service.layer >= service.layer:
                        violation = (
                            f"{svc_name} (L{service.layer}) depends on "
                            f"{dep_name} (L{dep_service.layer})"
                        )
                        violations.append(violation)
    
    return violations

# Example usage
if __name__ == "__main__":
    # Atlassian 2021 problem scenario
    services = {
        "artifactory": Service(
            name="artifactory",
            layer=5,
            dependencies={"micros": DependencyType.HARD}
        ),
        "micros": Service(
            name="micros",
            layer=5,
            dependencies={"artifactory": DependencyType.HARD}
        )
    }
    
    cycles = detect_circular_dependencies(services)
    print(f"Circular dependencies found: {cycles}")
    
    violations = validate_layering(services)
    print(f"Layer violations: {violations}")
#+end_src

Migration strategy:
- Move from Micros (Layer 5) to Kubernetes (Layer 5)
- Break cycle: Kubernetes can recover Artifactory
- Artifactory can then recover Micros

Scale handled:
- 2.5M requests/minute (~40K/second)
- 5 Gbps network traffic
- 250-400 TB downloaded daily
- 990 TB stored (348M objects)

*** Atlassian Platform Deployer (APD)

New low-dependency provisioning system to replace Micros for critical services.

Design principles:
- API-based web service
- No external database (AWS as source of truth)
- Uses CloudFormation as orchestration engine
- Minimal feature set (vs Micros)
- Restricted customer base (platform services only)

#+begin_src mermaid :file images/apd-stacks.png :tangle diagrams/apd-stacks.mmd
graph TB
    subgraph "Deployment v1.1"
        D2[Deployment Stack v1.1]
        DR2[Deployment Resources v1.1]
    end
    
    subgraph "Deployment v1.0 (cleanup)"
        D1[Deployment Stack v1.0]
        DR1[Deployment Resources v1.0]
    end
    
    subgraph "Persistent"
        E[Environment Stack]
        R[Route Stack]
        ER[Eternal Resources Stack]
    end
    
    R -->|traffic switch| D2
    R -.->|old traffic| D1
    E --> D2
    E -.-> D1
    D2 --> DR2
    D2 --> ER
    
    style D2 fill:#4caf50
    style D1 fill:#ff9800
    style R fill:#2196f3
#+end_src

** Phase 3: Support Systems (2023-2024)

*** Config Pillar
- Replaced higher-layer feature flag system
- AWS-native using Open Policy Agent (OPA)
- 700+ flags managed
- Available during recovery

*** Logging Pillar
- Kinesis stream as backup to observability pipeline
- Dormant during normal operations
- Activates during disasters
- Provides CloudWatch access for debugging

*** PaaS Dependency Visualization System (PDVS)
- Web frontend for all dependency data
- Tangle heat maps
- Recommendations for breaking cycles
- Model versioning and simulation
- VPC flow log integration

** Phase 4: Migration (2024-2025)

*** Traffic Migration Proxy (TMP)
- Envoy-based HTTP proxy sidecar
- Routes traffic between AWS accounts
- Synchronizes persistent stores (Dynamo, S3, RDS)
- Multi-region, multi-environment support

*** Micros Migration to APD
- July 2025 completion
- Phased rollout over several months
- Last critical service migrated

* Netflix's Approach

** Chaos Engineering Principles

1. *Build a hypothesis around steady state*
2. *Vary real-world events*
3. *Run experiments in production*
4. *Automate experiments*
5. *Minimize blast radius*

** Key Tools

*** Hystrix (Circuit Breaker)
- Fallback mechanisms
- Real-time monitoring
- Fault tolerance
- Dependency isolation

*** Eureka (Service Discovery)
- Dynamic service registration
- Health checks
- Load balancing integration

*** Chaos Monkey
- Random instance termination
- Validates resilience
- Forces best practices

** Layered Architecture Comparison

Both Netflix and Atlassian use similar concepts:
- Services organized by dependency levels
- Lower layers more stable/reliable
- Higher layers can fail without cascading
- Recovery proceeds bottom-up

* Workshop Exercises

** Exercise 1: Dependency Mapping

*** Goal
Map dependencies for a sample microservices architecture

*** Setup
#+begin_src python :tangle exercises/ex1_dependency_map.py
"""
Exercise 1: Create a dependency map for your services
"""
import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.dependency_analyzer import Service, DependencyType, detect_circular_dependencies, validate_layering

# Task 1: Add at least 5 services with dependencies
# We define a mix of services, including a deliberate circular dependency to demonstrate the issue.
services = {
    "load-balancer": Service(
        name="load-balancer",
        layer=3,
        dependencies={"auth-service": DependencyType.HARD} # Circular risk if auth needs LB
    ),
    "auth-service": Service(
        name="auth-service",
        layer=2,
        dependencies={"database": DependencyType.HARD}
    ),
    "database": Service(
        name="database",
        layer=1, # AWS RDS
        dependencies={}
    ),
    "app-server": Service(
        name="app-server",
        layer=4,
        dependencies={
            "auth-service": DependencyType.HARD,
            "database": DependencyType.HARD,
            "logging": DependencyType.SOFT
        }
    ),
    "logging": Service(
        name="logging",
        layer=5, 
        dependencies={"database": DependencyType.HARD}
    ),
    # Introduce the classic deploy cycle.
    "deployment-service": Service(
        name="deployment-service",
        layer=5,
        dependencies={"artifact-store": DependencyType.HARD}
    ),
    "artifact-store": Service(
        name="artifact-store",
        layer=4,
        dependencies={"deployment-service": DependencyType.HARD} # Cycle: needs deployment to be updated/managed
    )
}

def run_exercise():
    print("--- Task 2: Run circular dependency detection ---")
    cycles = detect_circular_dependencies(services)
    if cycles:
        print(f"Found circular dependencies: {cycles}")
    else:
        print("No circular dependencies found.")

    print("\n--- Task 3: Fix any cycles found ---")
    # Fix: artifact-store should not hard-depend on deployment-service for its basic operation/recovery
    print("Applying fix: Removing hard dependency from artifact-store to deployment-service (changing to SOFT)")
    services["artifact-store"].dependencies["deployment-service"] = DependencyType.SOFT
    
    cycles_fixed = detect_circular_dependencies(services)
    if cycles_fixed:
        print(f"Still found cycles: {cycles_fixed}")
    else:
        print("Cycles eliminated!")

    print("\n--- Verifying Layers ---")
    violations = validate_layering(services)
    if violations:
        print("Found layer violations:")
        for v in violations:
            print(f"  {v}")
    else:
        print("No layer violations found.")

if __name__ == "__main__":
    run_exercise()
#+end_src

** Exercise 2: Layer Assignment

*** Goal
Assign services to appropriate layers following the layer cake model

*** Constraints
- AWS/Cloud provider = Layer 1
- Products/Applications = Highest layer
- No hard dependencies on same/higher layers

#+begin_src python :tangle exercises/ex2_layer_assignment.py
"""
Exercise 2: Assign services to appropriate layers
"""
import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.dependency_analyzer import Service, DependencyType, validate_layering

services_data = {
    "database": {"current_layer": None, "dependencies": ["aws-rds"]},
    "auth": {"current_layer": None, "dependencies": ["database"]},
    "api": {"current_layer": None, "dependencies": ["auth", "database"]},
    "frontend": {"current_layer": None, "dependencies": ["api"]},
    "aws-rds": {"current_layer": 1, "dependencies": []},
}

def assign_layers(services_data):
    """
    Assign each service to a layer based on dependencies
    
    Rules:
    1. Services with no dependencies → Layer 2 (Layer 1 is cloud)
    2. Services depend only on lower layers
    3. Minimize layer count while respecting dependencies
    """
    print("Starting layer assignment...")
    
    # Reset layers (except fixed Layer 1)
    for s in services_data.values():
        if s.get("current_layer") != 1: 
            s["current_layer"] = None
            
    changed = True
    iteration = 0
    while changed:
        changed = False
        iteration += 1
        # Safe guard against infinite loops
        if iteration > 100:
            break
            
        for name, svc in services_data.items():
            if svc["current_layer"] is not None:
                continue
                
            # Check if all dependencies have layers
            deps_resolved = True
            max_dep_layer = 0
            
            for dep in svc["dependencies"]:
                if dep not in services_data:
                    # Skip unknown dependencies or assume they are external
                    continue
                    
                if services_data[dep]["current_layer"] is None:
                    deps_resolved = False
                    break
                max_dep_layer = max(max_dep_layer, services_data[dep]["current_layer"])
            
            if deps_resolved:
                # Assign layer: strictly greater than max dependency
                # If max_dep_layer is 0 (no deps), assign 2 (since 1 is cloud)
                if max_dep_layer == 0:
                     new_layer = 2
                else:
                     new_layer = max_dep_layer + 1
                
                svc["current_layer"] = new_layer
                changed = True
                print(f"Assigned {name} to Layer {new_layer}")

    # Check for unassigned (cycles)
    unassigned = [n for n, s in services_data.items() if s["current_layer"] is None]
    if unassigned:
        print(f"Could not assign layers to: {unassigned} (likely circular dependency)")
    else:
        print("\nLayer assignment complete:")
        # Sort by layer
        sorted_services = sorted(services_data.items(), key=lambda x: x[1]["current_layer"])
        for n, s in sorted_services:
            print(f"  Layer {s['current_layer']}: {n}")

# Task: Implement assign_layers() function
# Verify no layer violations exist
if __name__ == "__main__":
    assign_layers(services_data)
#+end_src

** Exercise 3: Simulate Tabletop Exercise

*** Scenario
Complete platform outage - recover services in order

*** Recovery Steps
#+begin_src python :tangle exercises/ex3_recovery_simulation.py
"""
Exercise 3: Simulate disaster recovery
"""
import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from typing import Set, Dict
import time
from src.dependency_analyzer import Service, DependencyType

class RecoverySimulation:
    def __init__(self, services: Dict[str, Service]):
        self.services = services
        self.recovered = set()
        self.failed_attempts = []
        
    def can_recover(self, service_name: str) -> bool:
        """
        Check if service can be recovered
        All hard dependencies must be recovered first
        """
        service = self.services[service_name]
        
        for dep_name, dep_type in service.dependencies.items():
            if dep_type == DependencyType.HARD:
                if dep_name not in self.recovered:
                    return False
        
        return True
    
    def recover_service(self, service_name: str) -> bool:
        """
        Attempt to recover a service
        """
        if self.can_recover(service_name):
            print(f"Recovering {service_name}...")
            # time.sleep(0.1) # Simulate time (commented out for speed)
            self.recovered.add(service_name)
            print(f"SUCCESS: {service_name} recovered.")
            return True
        else:
            # print(f"FAILED: Cannot recover {service_name}, missing dependencies.")
            self.failed_attempts.append(service_name)
            return False

    def run_recovery(self):
        """
        Attempt to recover all services until stable
        """
        print("Starting recovery simulation...")
        print(f"Total services to recover: {len(self.services)}")
        
        iteration = 0
        while len(self.recovered) < len(self.services):
            iteration += 1
            print(f"\n--- Iteration {iteration} ---")
            progress = False
            
            remaining = [s for s in self.services if s not in self.recovered]
            # Sort remaining by layer (low to high) to optimize recovery
            # This simulates the 'bottom-up' approach
            remaining.sort(key=lambda k: self.services[k].layer)
            
            for service_name in remaining:
                if self.recover_service(service_name):
                    progress = True
            
            if not progress:
                print("\nCRITICAL FAILURE: Deadlock detected. Cannot recover remaining services.")
                print(f"Unrecovered services: {remaining}")
                return False
                
        print("\nALL SERVICES RECOVERED SUCCESSFULLY!")
        return True

if __name__ == "__main__":
    # Setup services
    # Using a valid layered architecture
    services = {
        "aws-infra": Service("aws-infra", 1, {}),
        "iam": Service("iam", 2, {"aws-infra": DependencyType.HARD}),
        "vpc": Service("vpc", 3, {"iam": DependencyType.HARD, "aws-infra": DependencyType.HARD}),
        "database": Service("database", 4, {"vpc": DependencyType.HARD, "iam": DependencyType.HARD}),
        "app-api": Service("app-api", 5, {"database": DependencyType.HARD}),
        "frontend": Service("frontend", 6, {"app-api": DependencyType.HARD}),
        # Optional circular dependency to test failure
        # "circular-test": Service("circular-test", 5, {"frontend": DependencyType.HARD}),
    }
    
    # Inject bad dependency to test failure if needed
    # services["aws-infra"].dependencies["frontend"] = DependencyType.HARD 
    
    sim = RecoverySimulation(services)
    sim.run_recovery()
#+end_src

* Tools & Resources

** Open Source Chaos Tools

*** Production & Kubernetes
- [[https://chaos-mesh.org/][Chaos Mesh]]: Kubernetes-native, rich dashboard, deep fault injection.
- [[https://litmuschaos.io/][LitmusChaos]]: CI/CD integration, "Chaos Hub" for experiments.

*** Infrastructure as Code
- [[https://chaostoolkit.org/][Chaos Toolkit]]: Driver-based framework for AWS, Azure, Terraform.
- [[https://localstack.cloud/][LocalStack]]: Fault injection for simulated AWS services.

*** Networking & Messaging
- [[https://github.com/shopify/toxiproxy][Toxiproxy]]: Simulates network conditions (latency, bandwidth) for Kafka/RabbitMQ.
- [[https://github.com/alexei-led/pumba][Pumba]]: Chaos testing for Docker containers.

* Related Workshops & References

** Workshops
- [[https://github.com/azuredevcollege/chaos-eng-workshop][Azure Chaos Engineering Workshop]]: Kubernetes-based challenges.
- [[https://github.com/grace-maarten/platform-engineering-101][Platform Engineering 101]]: Red Hat Developer Hub focus.

** Reading List
- [[https://github.com/dastergon/awesome-chaos-engineering][Awesome Chaos Engineering]]: Curated list of resources.
- [[https://github.com/dastergon/awesome-sre][Awesome SRE]]: Site Reliability Engineering resources.

* Running the Workshop

** Prerequisites
- Python 3.9+
- Make
- Emacs (optional, for Org mode)

** Commands
#+begin_src bash
# Setup directories
make setup

# Run all exercises
make test

# Tangle code (requires Emacs)
make tangle
#+end_src
